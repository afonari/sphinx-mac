// ---------------------------------------------------------------------------
//
//      The ab-initio based multiscale library
//
//                  S / P H I / n X
//
//      Copyright:  Max-Planck-Institut fuer Eisenforschung GmbH
//                  40237 Duesseldorf, Germany
//
//      Contact:    https://sxrepo.mpie.de
//      Authors:    see sphinx/AUTHORS
//      License:    see sphinx/LICENSE
//
// ---------------------------------------------------------------------------

#include <SxAtomicOrbitals.h>
#include <SxNaturalCubicSpline.h>
#include <SxCubicSpline.h>
#include <SxFileIO.h>
#include <SxTextIO.h>
#include <SxSimpleParser.h>
#include <SxPseudoPot.h>
#include <SxPAWPot.h>
#include <SxPW.h>
#include <SxTextIO.h>
SxAtomicOrbitals::SxAtomicOrbitals ()
   : splineRep (false)
{
   // empty
}

SxAtomicOrbitals::SxAtomicOrbitals (
      const SxArray<SxArray<SxVector<double> > > &in,
      const SxConstPtr<SxBasis> &basisPtrIn,
      bool splineRepIn)
{
   basisPtr = basisPtrIn;
   muSet = in;
   splineRep = splineRepIn;

   // --- check dimensions
   for (int is = 0; is < in.getSize(); is++)  {
      int nOrbTypes = (int)in(is).getSize();
      for (int iot = 0; iot < nOrbTypes; iot++)  {
         SX_CHECK(in(is)(iot).auxData.n >= 0, (int)in(is)(iot).auxData.n);
         SX_CHECK(in(is)(iot).auxData.l >= 0, (int)in(is)(iot).auxData.l);
         SX_CHECK (muSet(is)(iot).auxData.is == is, muSet(is)(iot).auxData.is, is);
         if (basisPtr)  {
            muSet(is)(iot).setBasis (&*basisPtr);
#ifndef NDEBUG
            if (splineRepIn) {
               SX_CHECK (dynamic_cast<const SxRadialBasis*>(basisPtr.getPtr ()));
               SX_CHECK (in(is)(iot).getSize() == 4 * basisPtrIn->getNElements(),
                         in(is)(iot).getSize(), 4 * basisPtrIn->getNElements());
            } else  {
               SX_CHECK (in(is)(iot).getSize() == getRadFunc (is).getSize (),
                         in(is)(iot).getSize(), getRadFunc (is).getSize ());
            }
#endif
         }
      }
   }

   createFuncLMap ();
}

SxAtomicOrbitals::SxAtomicOrbitals (const SxArray<SxArray<int> > &lPhi,
                                    const SxPtr<SxBasis> &basisPtrIn,
                                    bool splineRepIn)
   : splineRep (splineRepIn),
     basisPtr (basisPtrIn),
     muSet (lPhi.getSize ())
{
   ssize_t nSpecies = lPhi.getSize ();
   refOrbMap.resize (nSpecies);
   SX_LOOP(is)  {
      int nOrb = 0;
      SX_LOOP(iot) nOrb += 2 * lPhi(is)(iot) + 1;
      refOrbMap(is).resize (nOrb);
      for (int io = 0, iot = 0; io < nOrb; ++iot)  {
         int l = lPhi(is)(iot);
         for (int m = -l; m <= l; ++m,++io)
            refOrbMap(is)(io).set (iot, l, m);
      }
      muSet(is).resize (lPhi(is).getSize ());
   }
   createFuncLMap ();
}

SxAtomicOrbitals::SxAtomicOrbitals (const SxArray<SxArray<SxAoIndex> > &map,
                                    const SxPtr<SxBasis> &basisPtrIn,
                                    bool splineRepIn)
   : splineRep (splineRepIn),
     basisPtr (basisPtrIn),
     muSet (map.getSize ()),
     refOrbMap(map)
{
   SX_LOOP(is)  {
      int nOrbType = 0;
      for (int io = 0; io < map(is).getSize (); ++nOrbType)
         io += 2 * map(is)(io).l + 1;
      muSet(is).resize (nOrbType);
   }
   createFuncLMap ();
}

SxAtomicOrbitals::SxAtomicOrbitals (const SxAtomicOrbitals &in)
   : splineRep (false)
{
   (*this) = in;
}

SxAtomicOrbitals::SxAtomicOrbitals (SxBinIO &io)
   : splineRep (false)
{

   basisPtr = SxPtr<SxRadBasis>::create(io);
   try  {
      read(io);
   } catch (SxException e)   {
      e.print ();
      SX_EXIT;
   }
   createFuncLMap ();
}

SxAtomicOrbitals::~SxAtomicOrbitals ()
{
   // empty
}

// rescale radial coordinate of orbital
static
SxVector<double> scaleOrbital (double scale, const SxVecRef<double> &orbital)
{
   SX_CHECK(scale > 1.0);
   const SxVecRef<double> &rad = orbital.getBasis<SxRadBasis> ()
                                 .radFunc(orbital.auxData.is);
   int l = orbital.auxData.l;
   SxVector<double> scaledRad = scale * rad;
   scaledRad(0) = 0.0;
   SxCubicSpline spline(scaledRad, orbital,
                        (l < 2) ? SxCubicSpline::NaturalHermite
                                : SxCubicSpline::Hermite);
   SxVector<double> newOrbital = spline.getY (rad);
   if (l > 0) newOrbital(0) = 0.;
   newOrbital.auxData = orbital.auxData;
   return newOrbital;
}


void SxAtomicOrbitals::setup (const SxSymbolTable *table)
{

   SX_CHECK (table);
   // SxRadBasis to be set up here ...
   SxPtr<SxRadBasis> newRad = SxPtr<SxRadBasis>::create ();
   basisPtr = newRad; // ... and kept as const object when we finish here

   // fromPotential cache
   class {
      private:
         SxMap<SxString, SxPtr<SxAtomicOrbitals> > orbs;

         /// the actual read routine
         void read (const SxString &name) {
            SxParser::Table potTable = SxParser ().read (name);
            SxPtr<SxRadBasis> rad;
            if (potTable->containsGroup("pseudoPot"))   {
               SxPseudoPot pot (&*potTable);
               orbs(name) = SxPtr<SxAtomicOrbitals>::create (
                               pot.getPseudoPsi (),
                               SxPtr<SxRadBasis>::create(pot.rad, pot.logDr));
            } else if (potTable->containsGroup("pawPot"))  {
               SxPAWPot pot (&*potTable);
               orbs(name) = SxPtr<SxAtomicOrbitals>::create (pot.getPhiPS (),
                               pot.getBasisLCAO ());
            } else {
               cout << "No known potential group found in file '"
                    << name << "'." << endl;
               cout << "SPHInX quits here!" << endl;
               SX_QUIT;
            }
         }
      public:
         /// Get rad basis from a sx input file
         const SxRadBasis& getBasis (const SxString &name)
         {
            if (!orbs.hasKey (name)) read (name);
            return orbs(name)->getRadBasis ();
         }
         /// Get orbitals from a sx input file
         const SxAtomicOrbitals& getOrbs (const SxString &name)
         {
            if (!orbs.hasKey (name)) read (name);
            return *orbs(name);
         }
   } fileCache;

   SYMBOLPARSE (table) {
      int iSpecies=-1;

      // get species
      FOREACH_SYMBOLGROUP("species")  {
         iSpecies++;
         // --- basis
         SYMBOLGROUP ("radBasis")  {
            SYMBOLGROUP("fromFile")  {
               SxString fileName = SYMBOLGET("file");
               int is = SYMBOLGET("is");
               SxRadBasis fileBasis;
               fileBasis.read(fileName);
               newRad->addMesh(fileBasis.radFunc(is), fileBasis.logDr(is));
            }
            SYMBOLGROUP("generate") {
               double rMin = SYMBOLGET("rMin");
               double rMax = SYMBOLGET("rMax");
               int nPoints = SYMBOLGET("nPoints");
               SxRadBasis genBasis;
               genBasis.set(rMin, rMax, nPoints);
               newRad->addMesh(genBasis.radFunc(0),genBasis.logDr(0));
            }
            SYMBOLGROUP("fromPotential")  {
               SxString potFile = SYMBOLGET("file");
               const SxRadBasis &fileBasis = fileCache.getBasis (potFile);
               int is = SYMBOLGET("is");
               newRad->addMesh (fileBasis.radFunc (is), fileBasis.logDr (is));
            }
            if (newRad->radFunc.getSize () != iSpecies + 1)  {
               // should never happen - invalid input file
               cout << "No known radial basis initialization specified!"
                    << endl;
               cout << "SPHInX quits here!" << endl;
               SX_QUIT;
            }
         }
         // --- orbitals
         int iOrbital = -1;
         SxVector<double> newOrbital;
         FOREACH_SYMBOLGROUP("orbital")
         {
            iOrbital++;
            SYMBOLGROUP("fromPotential") {
               SxString potFile = SYMBOLGET("file");
               const SxAtomicOrbitals &fromPot = fileCache.getOrbs (potFile);
               int l   = SYMBOLGET ("l");
               int iot = SYMBOLGET("iot");
               int is  = SYMBOLGET("is");
               newOrbital = fromPot(is,iot);
               const SxRadBasis &origBasis = fromPot.getRadBasis ();
               // Check Basis
               if (&origBasis != &getRadBasis ())  {
                  newOrbital = origBasis.changeRadBasis (&getRadBasis (),
                                                         newOrbital);
               }
               if (l != newOrbital.auxData.l) {
                  cout << "Inconsistent iot/l combination in fromPotential!"
                       << endl;
                  cout << "l is " << l
                       <<", should be " << int(newOrbital.auxData.l)
                       << endl;
                  SX_QUIT;
               }
               newOrbital.auxData.is = iSpecies;
               if (HAVE_SYMBOL("scale"))
                  newOrbital = scaleOrbital (SYMBOLGET("scale"), newOrbital);
               cout << "Add Orbital from Potential: is iot l " << is
                    << " " << iot << " " << l;
               addOrbital(newOrbital);
            }
            SYMBOLGROUP("fromFile")  {
               SxString fileName = SYMBOLGET("file");
               int l = SYMBOLGET("l");
               int iot = SYMBOLGET("iot");
               int is = SYMBOLGET("is");
               // read Orbitalfile & check Basis
               SxAtomicOrbitals fileOrbitals;
               if (HAVE_SYMBOL("Siesta"))  {
                  fileOrbitals.readSiesta(fileName, getRadFunc(is));
                  newOrbital = fileOrbitals(is,iot);
                  newOrbital.setBasis(&*basisPtr);
               } else  {
                  SxRadBasis vecBasis;
                  vecBasis.read(fileName);
                  fileOrbitals.read(fileName);
                  int nSpeciesFile = fileOrbitals.getNSpecies ();
                  if (is >= nSpeciesFile) {
                     cout << "Did not find species "
                          << is << " in quamol file " << fileName
                          << " with " << nSpeciesFile << " species." << endl;
                     SX_QUIT;
                  }
                  int nOrbTypesFile = fileOrbitals.getNOrbTypes(is);
                  if (iot >= nOrbTypesFile) {
                     cout << "Did not find orbitaltype iot="
                          << iot << " in quamol file " << fileName
                          << " with " << nOrbTypesFile << " orbital types."
                          << endl;
                     SX_QUIT;
                  }
                  if (HAVE_SYMBOL("rCut"))  {
                     double rCut = SYMBOLGET("rCut");
                     double rMin = vecBasis.getRMin(is);
                     double rMax = vecBasis.getRMax(is);
                     int nPoints = int ((double)vecBasis.getNPoints (is)
                                        * rCut / rMax);
                     SxRadialBasis cutRad (rMin, rCut, nPoints,
                                           /*realSpace=*/true);
                     newOrbital = vecBasis | ( cutRad | fileOrbitals(is,iot));
                  } else {
                     newOrbital = fileOrbitals(is,iot);
                     newOrbital.setBasis(vecBasis);
                  }

                  if (fabs (vecBasis.radFunc(is)(0)
                           - getRadFunc(iSpecies)(0)) > 1e-6 ||
                      fabs (vecBasis.logDr(is)
                            - getRadBasis ().logDr(iSpecies)) > 1e-6)
                     newOrbital = vecBasis.changeRadBasis(
                           &getRadBasis (),
                           newOrbital);
               }
               if (l != newOrbital.auxData.l) {
                  cout << "Inconsistent iot/l combination in fromFile!"
                       << endl;
                  cout << "l is " << l
                       <<", should be " << int(newOrbital.auxData.l)
                       << endl;
                  SX_QUIT;
               }
               newOrbital.auxData.is = iSpecies;
               if (HAVE_SYMBOL("scale"))
                  newOrbital = scaleOrbital (SYMBOLGET("scale"), newOrbital);
               cout << "Add Orbital from File: is iot l " << is
                    << " " << iot
                    << " " << l;
               addOrbital(newOrbital);
            }
            SYMBOLGROUP("fromWaves")  {
               SxString fileName = SYMBOLGET("file");
               int l      = SYMBOLGET("l");
               int iState = SYMBOLGET("iState");
               newOrbital = compressWave(fileName,iState,iSpecies,l);
               newOrbital.auxData.setAtom (iSpecies, -1);
               newOrbital.auxData.setOrb (-1, l, NONE_M);
               cout << "Add Orbital from wavestate: iState l "
                    << iState << " " << l;
               addOrbital(newOrbital);
            }
            SYMBOLGROUP("generateGaussian")  {
               double beta = SYMBOLGET("beta");
               int l = SYMBOLGET("l");
               if (l > 0) beta = beta * sqrt(2./l);
               const SxVector<double> &r = getRadFunc(iSpecies);
               SxVector<double> rPowL = r;
               if (l == 0) rPowL.set(1.0);
               for (int il = 2; il <= l; il++) rPowL *= r;
               newOrbital = rPowL * exp(-beta * r.sqr ());
               newOrbital.auxData.setAtom (iSpecies, -1);
               newOrbital.auxData.setOrb (-1, l, NONE_M);
               newOrbital.setBasis(&*basisPtr);
               if (l == 0)  {
                  cout << "Generate Gaussian Orbital: is l beta ";
                  cout << iSpecies;
                  cout << " " << l;
                  cout << " " << beta;
               } else  {
                  cout << "Generate Gaussian Orbital: is l rMax ";
                  cout << iSpecies;
                  cout << " " << l;
                  cout << " " << beta / sqrt(2./l);
               }
               addOrbital(newOrbital);
            }
            SYMBOLGROUP("gaussianBasis")  {
               SxVector<double> exps (SYMBOLGET("exponents")->toList());
               int nGauss = (int)exps.getSize ();
               SxVector<double> coeffs (SYMBOLGET("coefficients")->toList());
               int l = SYMBOLGET("l");
               if (nGauss != coeffs.getSize())  {
                  cout << "Wrong Number of coefficients: nGaussians is "
                       << nGauss << ", but have " << coeffs.getSize ()
                       << "coefficients!" << endl;
                  SX_QUIT;
               }
               const SxVector<double> &r = getRadFunc(iSpecies);
               int dim = (int)r.getSize();
               newOrbital.resize (dim);
               newOrbital.set(0.0);
               for (int iGauss = 0; iGauss < nGauss; iGauss++)  {
                  newOrbital
                     += coeffs(iGauss) * exp(-r.sqr () * exps(iGauss));
               }
               newOrbital *= pow(r, double(l));
               newOrbital.auxData.setAtom (iSpecies, -1);
               newOrbital.auxData.setOrb (-1, l, NONE_M);
               newOrbital.setBasis(&*basisPtr);
               cout << "Generate orbital via gaussian basis: is l nGauss ";
               cout << iSpecies;
               cout << " " << l;
               cout << " " << nGauss;
               addOrbital(newOrbital);
            }
            if (getNOrbTypes (iSpecies) != iOrbital + 1) {
               // should never happen - invalid input file
               cout << "No known Initialization shema found!" << endl;
               cout << "SPHInX quits here!" << endl;
               SX_QUIT;
            }
         }
      }
   }

   createFuncLMap ();
}

void SxAtomicOrbitals::addOrbital (const SxVecRef<double> &orbitalIN)
{
   SX_CHECK(basisPtr);

   int iSpecies = orbitalIN.auxData.is;
   int lIN =  orbitalIN.auxData.l;
   int iot = 0;
   if (iSpecies < getNSpecies ()) {
      int nOrbTypes = getNOrbTypes(iSpecies);
      muSet(iSpecies).resize(nOrbTypes + 1,true);
      for (iot = nOrbTypes; iot > 0; iot--)  {
         if (muSet(iSpecies)(iot-1).auxData.l > lIN)  {
            // shift existing orbitals with l > lIN
            muSet(iSpecies)(iot) = std::move(muSet(iSpecies)(iot-1));
            muSet(iSpecies)(iot).auxData.n = char(iot);
         } else {
            break;
         }
      }
#ifndef NDEBUG
      // make sure that orbitals below iot have smaller l's
      for (int jot = 0; jot < iot; jot++)  {
         SX_CHECK (muSet(iSpecies)(jot).auxData.l <= lIN,
                   iSpecies, jot, (int)muSet(iSpecies)(jot).auxData.l, lIN);
      }
#endif
      // shift iot's in funcLMap for all l's larger than current one
      int lmax = (int)funcLMap(iSpecies).getSize () - 1;
      for (int l = lIN + 1; l <= lmax; l++)
         SX_LOOP(ifl) funcLMap(iSpecies)(l)(ifl)++;
      // append new orbital in funcLMap
      if (lIN <= lmax)  {
         // append for existing l
         int nOrbL = (int)funcLMap(iSpecies)(lIN).getSize ();
         funcLMap(iSpecies)(lIN).resize (nOrbL + 1);
         funcLMap(iSpecies)(lIN)(nOrbL) = iot;
      } else {
         // add new l
         funcLMap(iSpecies).resize (lIN + 1, true);
         funcLMap(iSpecies)(lIN).resize (1);
         funcLMap(iSpecies)(lIN)(0) = iot;
      }
   } else {
      // append new species
      muSet.resize (iSpecies + 1, true);
      muSet(iSpecies).resize(1);
      funcLMap.resize (iSpecies + 1, true);
      funcLMap(iSpecies).resize (lIN + 1);
      funcLMap(iSpecies)(lIN).resize (1);
      funcLMap(iSpecies)(lIN)(0) = iot;// = 0
   }
   // insert orbital now
   muSet(iSpecies)(iot) = orbitalIN;
   muSet(iSpecies)(iot).auxData.setAtom (iSpecies, -1);
   muSet(iSpecies)(iot).auxData.setOrb (iot, lIN, NONE_M);
   muSet(iSpecies)(iot).setBasis(&*basisPtr);
   cout << " as " << iSpecies << " " << iot << " " << lIN << endl;
}


void SxAtomicOrbitals::operator+= (const SxAtomicOrbitals &in)
{
   SX_CHECK(splineRep == in.splineRep);
   SX_LOOP2(is,iot) {
      SX_CHECK(muSet(is)(iot).getSize() == in.muSet(is)(iot).getSize(),
               muSet(is)(iot).getSize(), in.muSet(is)(iot).getSize());
      muSet(is)(iot) += in.muSet(is)(iot);
   }
}

void SxAtomicOrbitals::operator-= (const SxAtomicOrbitals &in)
{
   SX_CHECK(splineRep == in.splineRep);
   SX_LOOP2(is,iot)  {
      SX_CHECK(muSet(is)(iot).getSize() == in.muSet(is)(iot).getSize(),
               muSet(is)(iot).getSize(), in.muSet(is)(iot).getSize());
      muSet(is)(iot) -= in.muSet(is)(iot);
   }
}

SxAtomicOrbitals SxAtomicOrbitals::operator+ (const SxAtomicOrbitals &in) const
{
   SX_CHECK(splineRep == in.splineRep);
   SX_CHECK(basisPtr->getNElements() == in.basisPtr->getNElements());
   int nSpecies = (int)muSet.getSize();
   SX_CHECK(nSpecies == in.getNSpecies(), nSpecies, in.getNSpecies());
   SxArray<SxArray<SxVector<double> > > resMuSet(nSpecies);
   for (int is = 0; is < nSpecies; is++)   {
      int nOrbTypes = getNOrbTypes (is);
      SX_CHECK(nOrbTypes == in.getNOrbTypes(is),
               nOrbTypes, in.getNOrbTypes(is));
      resMuSet(is).resize(nOrbTypes);
      for (int iot = 0; iot < nOrbTypes; iot++)   {
         resMuSet(is)(iot) = muSet(is)(iot) + in.muSet(is)(iot);
         resMuSet(is)(iot).auxData.is = in.muSet(is)(iot).auxData.is;
         resMuSet(is)(iot).auxData.n  = in.muSet(is)(iot).auxData.n;
         resMuSet(is)(iot).auxData.l  = in.muSet(is)(iot).auxData.l;
      }
   }
   SxAtomicOrbitals result = SxAtomicOrbitals(resMuSet, basisPtr, splineRep);

   return result;
}

void SxAtomicOrbitals::sumMPI() const
{
   ssize_t nSpecies = muSet.getSize();
   SxArray<SxArray<SxVector<double> > > resMuSet(nSpecies);
   for (int is = 0; is < nSpecies; is++)   {
      ssize_t nOrbTypes = getNOrbTypes (is);
      resMuSet(is).resize(nOrbTypes);
      for (ssize_t iot = 0; iot < nOrbTypes; iot++)
         SxLoopMPI::sum (muSet(is)(iot));
   }
}

SxAtomicOrbitals SxAtomicOrbitals::operator- (const SxAtomicOrbitals &in) const
{
   SX_CHECK(splineRep == in.splineRep);
   SX_CHECK(basisPtr->getNElements() == in.basisPtr->getNElements());
   int nSpecies = (int)muSet.getSize();
   SX_CHECK(nSpecies == in.getNSpecies(), nSpecies, in.getNSpecies());
   SxArray<SxArray<SxVector<double> > > resMuSet(nSpecies);
   for (int is = 0; is < nSpecies; is++)   {
      int nOrbTypes = getNOrbTypes (is);
      SX_CHECK(nOrbTypes == in.getNOrbTypes(is),
               nOrbTypes, in.getNOrbTypes(is));
      resMuSet(is).resize(nOrbTypes);
      for (int iot = 0; iot < nOrbTypes; iot++)   {
         resMuSet(is)(iot) = muSet(is)(iot) - in.muSet(is)(iot);
         resMuSet(is)(iot).auxData.is = in.muSet(is)(iot).auxData.is;
         resMuSet(is)(iot).auxData.n  = in.muSet(is)(iot).auxData.n;
         resMuSet(is)(iot).auxData.l  = in.muSet(is)(iot).auxData.l;
      }
   }
   SxAtomicOrbitals result = SxAtomicOrbitals(resMuSet, basisPtr, splineRep);

   return result;
}

SxAtomicOrbitals SxAtomicOrbitals::operator* (double skalar) const
{
   SX_CHECK(basisPtr->getNElements() > 0);
   int nSpecies = (int)muSet.getSize();
   SxArray<SxArray<SxVector<double> > > resMuSet(nSpecies);
   for (int is = 0; is < nSpecies; is++)   {
      int nOrbTypes = getNOrbTypes(is);
      resMuSet(is).resize(nOrbTypes);
      for (int iot = 0; iot < nOrbTypes; iot++)   {
         resMuSet(is)(iot) = muSet(is)(iot) * skalar;
         resMuSet(is)(iot).auxData.is = muSet(is)(iot).auxData.is;
         resMuSet(is)(iot).auxData.n  = muSet(is)(iot).auxData.n;
         resMuSet(is)(iot).auxData.l  = muSet(is)(iot).auxData.l;
      }
   }
   SxAtomicOrbitals result = SxAtomicOrbitals(resMuSet, basisPtr, splineRep);

   return result;
}

SxAtomicOrbitals SxAtomicOrbitals::operator/ (double skalar) const
{
   SX_CHECK(basisPtr->getNElements() > 0);
   int nSpecies = (int)muSet.getSize();
   SxArray<SxArray<SxVector<double> > > resMuSet(nSpecies);
   for (int is = 0; is < nSpecies; is++)   {
      int nOrbTypes = getNOrbTypes(is);
      resMuSet(is).resize(nOrbTypes);
      for (int iot = 0; iot < nOrbTypes; iot++)   {
         resMuSet(is)(iot) = muSet(is)(iot) / skalar;
         resMuSet(is)(iot).auxData.is = muSet(is)(iot).auxData.is;
         resMuSet(is)(iot).auxData.n  = muSet(is)(iot).auxData.n;
         resMuSet(is)(iot).auxData.l  = muSet(is)(iot).auxData.l;
      }
   }
   SxAtomicOrbitals result = SxAtomicOrbitals(resMuSet, basisPtr, splineRep);

   return result;
}

const SxVecRef<double>
SxAtomicOrbitals::operator() (int is, int ia, int iot, int l, int m) const
{
   SxVecRef<double> result = const_cast<SxVector<double>&>(muSet(is)(iot));
   // Set auxData
   result.setBasis(*basisPtr);
   result.auxData.is = is;
   result.auxData.ia = ia;
   result.auxData.n  = char(iot);
   result.auxData.l  = char(l);
   result.auxData.m  = char(m);

   return result;
}

int SxAtomicOrbitals::getIOT (int is, int n, int l) const
{
   int iot = 0;
   while ((muSet(is)(iot).auxData.n != n)
         || (muSet(is)(iot).auxData.l != l))   {
      iot++;
      if (iot >= muSet(is).getSize()) SX_EXIT;
   }

   return iot;
}

int SxAtomicOrbitals::getOrbitalIdx (int is, int ia, int iot, int l, int m, const SxArray<SxQuantumNumbers> &map) const
{
   for (int iOrbital = 0; iOrbital < map.getSize(); iOrbital++)  {
      if (map(iOrbital).iSpecies == is  &&
          map(iOrbital).iAtom    == ia  &&
          map(iOrbital).n        == iot &&
          map(iOrbital).l        == l   &&
          map(iOrbital).m        == m) return iOrbital;
   }

   cout << "OrbitalIdx with is = " << is << ", ia = " << ia
        << ", n = " << iot << ", l = " << l << ", m = " << m
        << " not found!" << endl;
   SX_EXIT;
}

int SxAtomicOrbitals::getNOrbTypes () const
{
   int result = 0;
   for(int is = 0; is < getNSpecies (); is++)
      result += getNOrbTypes(is);

   return result;
}

SxArray<SxQuantumNumbers> SxAtomicOrbitals::getReducedOrbitalMap () const
{
   SX_CHECK(&muSet);
   int nSpecies = (int)muSet.getSize ();
   SxList<SxQuantumNumbers> list;
   for(int is = 0; is < nSpecies; is++)   {
      int nOrbLocal = (int)muSet(is).getSize();
      for(int iot = 0; iot < nOrbLocal; iot++)   {
         int l = muSet(is)(iot).auxData.l;
         // SxQuantumNumberConstructor forbids uninitialized ia and m
         SxQuantumNumbers qNumbers (is,0,iot,l,0);
         // Therefore unset it here
         qNumbers.iAtom = -1; qNumbers.m = NONE_M;
         list.append(qNumbers);
      }
   }
   SxArray<SxQuantumNumbers> result = SxArray<SxQuantumNumbers>(list);

   return result;
}


SxArray<SxQuantumNumbers>
SxAtomicOrbitals::getOrbitalMap (const SxAtomicStructure &structure) const
{
   SX_CHECK(&muSet);
   int nSpecies = (int)muSet.getSize ();
   SxList<SxQuantumNumbers> list;
   for(int is = 0; is < nSpecies; is++)   {
      int nAtoms = structure.getNAtoms(is);
      int nOrbLocal = (int)muSet(is).getSize();
      for(int ia = 0; ia < nAtoms; ia++)   {
         for(int iot = 0; iot < nOrbLocal; iot++)   {
            int l = muSet(is)(iot).auxData.l;
            for(int m = -l; m <= l; m++)   {
               list.append(SxQuantumNumbers(is,ia,iot,l,m));
            }
         }
      }
   }

   SxArray<SxQuantumNumbers> result = SxArray<SxQuantumNumbers>(list);

   return result;
}

int SxAtomicOrbitals::getNOrbitals (const SxAtomicStructure &structure) const
{
   SX_CHECK(muSet.getSize() > 0);
   int nSpecies = (int)muSet.getSize ();
   int result = 0;
   for(int is = 0; is < nSpecies; is++)   {
      int nAtoms = structure.getNAtoms(is);
      int nOrbLocal = (int)muSet(is).getSize();
      for(int ia = 0; ia < nAtoms; ia++)   {
         for(int iot = 0; iot < nOrbLocal; iot++)   {
            int l = muSet(is)(iot).auxData.l;
            result += 2*l+1;
         }
      }
   }

   return result;
}

void SxAtomicOrbitals::createFuncLMap ()
{
   int nSpecies = (int)muSet.getSize ();
   if (refOrbMap.getSize () == 0)  {
      refOrbMap.resize (nSpecies);
      SX_LOOP(is)  {
         int nOrb = 0;
         SX_LOOP(iot) nOrb += 2*muSet(is)(iot).auxData.l + 1;
         refOrbMap(is).resize (nOrb);
         for (int io = 0, iot = 0; io < nOrb; ++iot)  {
            const SxAuxData &aux = muSet(is)(iot).auxData;
            for (int m=-aux.l; m <= aux.l; ++m)
               refOrbMap(is)(io++).set (aux.n, aux.l, m);
         }
      }
   }
   funcLMap.resize(nSpecies);
   for(int iSpecies = 0; iSpecies < nSpecies; iSpecies++)   {
      const SxArray<SxAoIndex> &orbMap = refOrbMap(iSpecies);
      // find lMax
      int lMax = 0;
      for (auto nlm : refOrbMap(iSpecies))
         if (lMax < nlm.l) lMax=nlm.l;

      // --- find number of functions per l-channel
      funcLMap(iSpecies).resize(lMax + 1);
      SxArray<int> funcPerL(lMax + 1);
      funcPerL.set(0);
      for (int io = 0; io < orbMap.getSize  (); )  {
         int l = orbMap(io).l;
         funcPerL(l)++;
         io += 2 * l + 1;
      }
      for (int l = 0; l <= lMax; l++)
         funcLMap(iSpecies)(l).resize(funcPerL(l));

      // create map from l,iFuncL -> iot
      funcPerL.set(0);
      for (int io = 0, iot = 0; io < orbMap.getSize (); iot++)  {
         int l = refOrbMap(iSpecies)(io).l;
         funcLMap(iSpecies)(l)(funcPerL(l)++) = iot;
         io += 2 * l + 1;
      }
   }
}

SxVector<double> &SxAtomicOrbitals::getFuncL (int is, int l, int ifl)
{
   int iot = funcLMap(is)(l)(ifl);
   return muSet(is)(iot);
}

const SxVector<double> &SxAtomicOrbitals::getFuncL (int is, int l, int ifl) const
{
   int iot = funcLMap(is)(l)(ifl);
   return muSet(is)(iot);
}

int SxAtomicOrbitals::getLMax () const
{
   int lMax = 0, nSpecies = (int)refOrbMap.getSize ();
   for (int is = 0; is < nSpecies; ++is)
      lMax = max(lMax, getLMax (is));
   return lMax;
}

SxArray<SxArray<int> > SxAtomicOrbitals::getFuncPerL () const
{
   int nSpecies = (int)muSet.getSize ();
   SxArray<SxArray<int> > result(nSpecies);
   for(int iSpecies = 0; iSpecies < nSpecies; iSpecies++)   {
      int lMax = getLMax (iSpecies);
      result(iSpecies).resize(lMax + 1);
      for(int l = 0; l <= lMax; l++)   {
         result(iSpecies)(l) = getFuncPerL(iSpecies,l);
      }
   }
   return result;
}

int SxAtomicOrbitals::getFuncPerL (int is, int l) const
{
   return (int)funcLMap(is)(l).getSize();
}

void SxAtomicOrbitals::print (const SxString &file) const
{
   int nSpecies = getNSpecies();
   SX_CHECK (   dynamic_cast<const SxRadBasis*>   (basisPtr.getPtr ())
             || dynamic_cast<const SxRadialBasis*>(basisPtr.getPtr ()) );
   for(int is = 0; is < nSpecies; is++)   {
      const SxVecRef<double> &rad = getRadFunc (is);
      int nOrbTypes = getNOrbTypes(is);
      for (int iot = 0; iot < nOrbTypes; iot++)   {
         SxString outFile = file + SxString(is) + SxString(iot) + ".dat";
         SxVecRef<double> vec;
         if (splineRep) vec = toVec(is,iot);
         else           vec = muSet(is)(iot);
         SxTextIO (outFile).writeXYPlot(rad, vec);
      }
   }
}

void SxAtomicOrbitals::write (SxBinIO &io) const
{
   SX_CHECK(basisPtr);
   const SxRadBasis &radBasis = getRadBasis ();
   int nSpecies = getNSpecies();

   try {
      //create dimensions
      io.addDimension ("nSpecies", nSpecies);
      for (int is = 0; is < nSpecies; is++)   {
         io.addDimension ("dimOrbTypes-"+SxString(is), getNOrbTypes(is));
         io.addDimension ("dimRad-"+SxString(is),
                          (int)radBasis.radFunc(is).getSize());
      }
      //write data
      SxArray<SxVector<int> > lNumbers (nSpecies);
      for (int is = 0; is < nSpecies; is++)   {
         SxString radialName= "radFunc-" + SxString(is);
         SxString dimRadName = "dimRad-" + SxString(is);
         io.write (radialName, radBasis.radFunc(is), dimRadName);
         SxString logDrName= "logDr-" + SxString(is);
         io.write (logDrName, radBasis.logDr(is));
         lNumbers(is).resize(getNOrbTypes(is));
         for (int iot=0; iot < getNOrbTypes(is); iot++)   {
            radialName= "radial-" + SxString(is) + "-" + SxString(iot);
            io.write (radialName, muSet(is)(iot), dimRadName);
            lNumbers(is)(iot) = muSet(is)(iot).auxData.l;
         }
         SxString lName= "lNumbers-" + SxString(is);
         io.write (lName, lNumbers(is),"dimOrbTypes-"+SxString(is));
      }
   } catch (SxException e)   {
      e.print ();
      SX_EXIT;
   }
}

void SxAtomicOrbitals::write (const SxString &filename) const
{
   SxBinIO io(filename, SxBinIO::BINARY_WRITE_ONLY);
   write(io);
   io.setMode (SxBinIO::WRITE_DATA);
   write(io);
   io.close();
}

void SxAtomicOrbitals::read (SxBinIO &io)
{

   try {
      basisPtr = SxPtr<SxRadBasis>::create(io);
      //get dimensions
      int nSpecies = io.getDimension ("nSpecies");
      muSet.resize(nSpecies);
      for (int is = 0; is < nSpecies; is++)   {
         int nOrbTypes = io.getDimension ("dimOrbTypes-"+SxString(is));
         muSet(is).resize(nOrbTypes);
         int dimRad = io.getDimension ("dimRad-"+SxString(is));
         SxVector<int> lVec (nOrbTypes);
         SxString lName= "lNumbers-" + SxString(is);
         io.read (lName,&lVec,nOrbTypes);
         // TODO further check of SxRadBasis
         for (int iot=0; iot < nOrbTypes; iot++)   {
            muSet(is)(iot).resize(dimRad);
            SxString radialName= "radial-" + SxString(is) + "-" + SxString(iot);
            SxVector<double> &readVec = muSet(is)(iot);
            io.read (radialName,&readVec,dimRad);
            muSet(is)(iot).setBasis (&*basisPtr);
            muSet(is)(iot).auxData.is = is;
            muSet(is)(iot).auxData.setOrb (iot, lVec(iot), 0);
         }
      }
   } catch (SxException e)   {
      e.print ();
      SX_EXIT;
   }

   createFuncLMap ();
}

void SxAtomicOrbitals::read (const SxString &file)
{
   try  {
      SxBinIO io (file, SxBinIO::BINARY_READ_ONLY);
      read (io);
      io.close ();
   } catch (SxException e)  {
      e.print ();
      SX_EXIT;
   }
}
void SxAtomicOrbitals::writeSiesta (const SxArray<SxString> &file,
                                    const SxArray<SxVector<double> > &basis)
{
   int nSpecies = getNSpecies ();
   SX_CHECK (basis.getSize () == nSpecies);
   SX_CHECK (file.getSize () == nSpecies);

   for (int iSpecies = 0; iSpecies < nSpecies; iSpecies++)   {
      SxTextIO io(file(iSpecies));
      int oldL = -1;
      int z = 0;
      for (int iot = 0; iot < getNOrbTypes (iSpecies); iot++)  {
         // orbital header
         int l = muSet(iSpecies)(iot).auxData.l;
         if (l == oldL)  z++;
         else {
            z = 0;
            oldL = l;
         }
         io.printf("%i ? %i ? 0.000000 #orbital l, n, z, is_polarized, population\n",
                   l,z);
         int npts = (int)basis(iSpecies).getSize ();
         double delta = basis(iSpecies)(1) - basis(iSpecies)(0);
         double cutoff = basis(iSpecies)(npts-1);
         io.printf("%i %.12e %.12f # npts, delta, cutoff\n",npts, delta, cutoff);
         SxCubicSpline spline (getRadFunc(iSpecies), muSet(iSpecies)(iot),
                               SxCubicSpline::Natural);
         SxVector<double> orbital = spline.getY(basis(iSpecies));
         orbital(npts-1) = 0.0;
         if (l != 0) orbital(0) = 0.0;
         // data
         io.writeXYPlot (basis(iSpecies), orbital);
      }
   }
}


void SxAtomicOrbitals::readSiesta (const SxString &file,
                                   const SxVecRef<double> &radFunc)
{
   SxString ionFile;
   SxList<SxString> cLine;
   SxString data;
   muSet.resize(1);

   try {
      ionFile = SxFileIO::readBinary (file,-1);
   } catch (SxException e)  {
      e.print ();
      SX_EXIT;
   }
   SxList<SxString> ionFileTok = ionFile.tokenize ('\n');
   int line = 0;
   while (ionFileTok(line).contains("# Lmax for basis, no. of nl orbitals") == 0)
      if (line >= ionFileTok.getSize()) {
         cout << "Expression not found" << endl;
         SX_EXIT;
      }
   data = ionFileTok(line).left("#").stripWhiteSpace ();
   //int lMax = (data.left(" ").stripWhiteSpace ()).toInt ();
   int nOrbTypes = (data.right(" ").stripWhiteSpace ()).toInt ();
   muSet(0).resize(nOrbTypes);
   for (int iot = 0; iot < nOrbTypes; iot++)  {
      while (ionFileTok(line).contains("#orbital") == 0) {
         line++;
         if (line >= ionFileTok.getSize()) {
            cout << "Expression not found" << endl;
            SX_EXIT;
         }
      }
      cLine = ionFileTok(line).left('#').stripWhiteSpace ().tokenize(' ');
      int l = cLine.first ().toInt ();
      line++;
      cLine = ionFileTok(line).left('#').stripWhiteSpace ().tokenize(' ');
      int nPoints = cLine.first ().toInt ();
      //int cutoff = cLine.last ().toInt ();
      SxVector<double> x (nPoints);
      SxVector<double> y (nPoints);
      line++;
      for (int iPoint = 0; iPoint < nPoints; iPoint++,line++)  {
         x(iPoint) = ionFileTok(line).stripWhiteSpace ().left (' ')
            .stripWhiteSpace ().toDouble();
         y(iPoint) = ionFileTok(line).stripWhiteSpace ().right(' ')
            .stripWhiteSpace ().toDouble();
      }
      SxCubicSpline spline(x,y,
            SxCubicSpline::Natural);
      muSet(0)(iot) = spline.getY(radFunc);
      // Set auxdata
      SxRadBasis::TPsi &mu = muSet(0)(iot);
      mu.auxData.setAtom (-1, -1);
      mu.auxData.setOrb (iot, l, NONE_M);
   }

   createFuncLMap ();

}

void SxAtomicOrbitals::setBasis (const SxConstPtr<SxBasis> &basisPtrIn)
{
   basisPtr = basisPtrIn;
   for (int is = 0; is < muSet.getSize (); ++is)
      for (int iot = 0; iot < muSet(is).getSize (); ++iot)
         muSet(is)(iot).setBasis (basisPtr.getConstPtr ());
}

void SxAtomicOrbitals::readOrbital (FILE *fp, int is, int n, int l, int iot,
                                    bool ignoreComments)
{
   SX_CHECK (fp);
   SX_CHECK (is >= 0 && (   (is <= getNSpecies () && iot == -1)
             || (is < getNSpecies ())),
             is, getNSpecies (), iot);
   SX_CHECK (l >= 0, l);
   SX_CHECK ((iot >= 0 && iot < muSet(is).getSize ()) || (iot == -1),
             iot, muSet(is).getSize ());

   // --- read the file
   int N = 0;
   char c;
   SxStack<double> rFile, psiFile;
   while (!feof(fp))  {
      if (ignoreComments)  {
         while (fscanf (fp, " #%c", &c) == 1)  {
            // comment line
            while (c != '\n')  {
               if (feof(fp)) break;
               c = (char)fgetc (fp);
            }
         }
      }
      double r, f;
      if (fscanf(fp, "%lf %lf", &r, &f) == 2)  {
         rFile << r;
         psiFile << f;
         N++;
      } else {
         break;
      }
   }
   if (N == 0)  {
      cout << "Could not read orbital from text file!" << endl;
      SX_EXIT;
   }

   // --- transform data to vectors
   SxVector<double> r(rFile), psi(psiFile);

   // --- change radial grid?
   if (basisPtr)  {
     const SxRadBasis &radBasis = getRadBasis ();
      if (N != radBasis.radFunc(is).getSize ()
          || (radBasis.radFunc(is) - r).normSqr () > 1e-10)
      {
         // --- spline interpolation
         SxNaturalCubicSpline spline;
         if (l == 0)
            spline = SxNaturalCubicSpline (r, r * r * psi);
         else
            spline = SxNaturalCubicSpline (r, psi);
         // linear extrapolation below r0
         double rmax = r(r.getSize () - 1), rmin = r(0);
         double dpsi0 = (psi(1) - psi(0)) / (r(1) - r(0)),
                psi0 = psi(0);

         // --- get psi on rBasis radial grid
         psi = SxVector<double>(radBasis(is));
         for (int ir = 0; ir < radBasis.radFunc(is).getSize (); ++ir)  {
            double rr = radBasis.radFunc(is)(ir);
            if (rr > rmax)  {
               psi(ir) = 0.;
            } else if (rr < rmin)  {
               psi(ir) = psi0 + (rr - rmin) * dpsi0;
            } else {
               psi(ir) = spline.getVal (rr);
               if (l == 0) psi(ir) /= rr * rr;
            }
         }
         SX_VALIDATE_VECTOR (psi);
      }
   }

   // --- metadata
   if (iot != -1 && muSet(is)(iot).getSize () > 0)
      psi.auxData = muSet(is)(iot).auxData;
   psi.auxData.is = is;
   psi.auxData.n = char(n);
   psi.auxData.l = char(l);

   // --- store away data in right place
   if (iot == -1)
      addOrbital (psi);
   else
      muSet(is)(iot) = psi;
}

void SxAtomicOrbitals::readOrbitals (FILE *fp, int is)
{
   char buffer[10240];
   int n, l;
   SxRegex lMatch("l *= *([0-9]+)");
   SxRegex nMatch("n *= *([0-9]+)");
   for ( ; !feof(fp); )  {
      buffer[0] = 0;
      char *res = fgets (buffer, 10240, fp);
      if (!res) {
         if (feof(fp)) break;
         cout << "Error while reading file" << endl;
         SX_QUIT;
      }
      SxString line(buffer);
      line = line.stripWhiteSpace ();
      if (line.getSize () <= 1) continue;
      SxList<SxString> match;
      n = muSet.getSize () >= is ? 0 : (int)muSet(is).getSize ();
      try {
         match = lMatch.match (line);
         if (match.getSize () == 2)  {
            cout << line;
            cout << match(0) << endl;
            l = match(1).toInt ();
         } else {
            cout << match << endl;
            cout << "Missing l in '" << line << "'." << endl;
            SX_EXIT;
         }
         match = nMatch.match (line);
         if (match.getSize () == 2) n = match(1).toInt ();
      } catch (SxException e)  {
         e.print ();
         SX_EXIT;
      }
      readOrbital (fp, is, n, l, -1, false);
   }
}


double SxAtomicOrbitals::getNormSqr(int is, int iot) const
{
   SxVecRef<double> vec;
   if (splineRep) vec = toVec(is,iot);
   else           vec = muSet(is)(iot);
   return tr(vec * vec);
}

double SxAtomicOrbitals::getNormSqrSum() const
{
   double result = 0.0;
   int nSpecies = (int)muSet.getSize();
   for (int is = 0; is < nSpecies; is++)  {
      int nOrbTypes = (int)muSet(is).getSize ();
      for (int iot = 0; iot < nOrbTypes; iot++)  {
         result += getNormSqr(is,iot);
      }
   }

   return result;
}
double SxAtomicOrbitals::dot (const SxAtomicOrbitals &orbitalsIn) const
{
   double result = 0.0;
   int nSpecies = getNSpecies ();
   SX_CHECK(nSpecies == orbitalsIn.getNSpecies());

   for (int is = 0; is < nSpecies; is++)  {
      SX_CHECK (getNOrbTypes(is) == orbitalsIn.getNOrbTypes (is));
      int nOrbTypes = (int)muSet(is).getSize ();
      for (int iot = 0; iot < nOrbTypes; iot++)  {
         result += dot(orbitalsIn,is,iot,is,iot);
      }
   }

   return result;
}

double SxAtomicOrbitals::dot (const SxAtomicOrbitals &orbitalsIn, int is, int iot, int js, int jot) const
{
   SX_CHECK(basisPtr == orbitalsIn.basisPtr);
   SxVecRef<double> vec1;
   if (splineRep) vec1 = toVec(is,iot);
   else           vec1 = muSet(is)(iot);
   SxVecRef<double> vec2;
   if (orbitalsIn.splineRep) vec2 = orbitalsIn.toVec(js,jot);
   else           vec2 = orbitalsIn.muSet(js)(jot);
   return tr(vec1 * vec2);
}

double SxAtomicOrbitals::sum (const SxAtomicOrbitals &orbitalsIn) const
{
   double result = 0.0;
   int nSpecies = getNSpecies ();
   SX_CHECK(nSpecies == orbitalsIn.getNSpecies());

   for (int is = 0; is < nSpecies; is++)  {
      SX_CHECK (getNOrbTypes(is) == orbitalsIn.getNOrbTypes (is));
      int nOrbTypes = (int)muSet(is).getSize ();
      for (int iot = 0; iot < nOrbTypes; iot++)  {
         result += sum(orbitalsIn,is,iot,is,iot);
      }
   }

   return result;
}

double SxAtomicOrbitals::sum (const SxAtomicOrbitals &orbitalsIn, int is, int iot, int js, int jot) const
{
   SX_CHECK(basisPtr == orbitalsIn.basisPtr);
   SxVecRef<double> vec1;
   if (splineRep) vec1 = toVec(is,iot);
   else           vec1 = muSet(is)(iot);
   SxVecRef<double> vec2;
   if (orbitalsIn.splineRep) vec2 = orbitalsIn.toVec(js,jot);
   else           vec2 = orbitalsIn.muSet(js)(jot);
   double result = (vec1 * vec2).sum ();
   return result;
}

void SxAtomicOrbitals::toSpline () const
{
   SX_CHECK (!splineRep);
   if (!splineRep)  {
      const SxVecRef<double> &radGFunc
         = SxConstPtr<SxRadialBasis>(basisPtr)->getRadFunc();
      int nSpecies = getNSpecies ();
      for (int is = 0; is < nSpecies; is++)   {
         int nOrbtypes = getNOrbTypes (is);
         for (int iot = 0; iot < nOrbtypes; iot++)   {
            SX_CHECK(is == muSet(is)(iot).auxData.is,
                     is, muSet(is)(iot).auxData.is);
            int ia = muSet(is)(iot).auxData.ia;
            int n = muSet(is)(iot).auxData.n;
            int l = muSet(is)(iot).auxData.l;
            int m = muSet(is)(iot).auxData.m;
            SxCubicSpline spline;
            if (l < 2)
               spline = SxCubicSpline (
                     radGFunc,
                     muSet(is)(iot),
                     SxCubicSpline::NaturalHermite);
            else
               spline = SxCubicSpline (
                     radGFunc,
                     muSet(is)(iot),
                     SxCubicSpline::Hermite);
            muSet(is)(iot) = spline.getSpline ();
            muSet(is)(iot).setBasis(&*basisPtr);
            muSet(is)(iot).auxData.is = is;
            muSet(is)(iot).auxData.ia = ia;
            muSet(is)(iot).auxData.n = char(n);
            muSet(is)(iot).auxData.l = char(l);
            muSet(is)(iot).auxData.m = char(m);
         }
      }
      splineRep = true;
   }
}

void SxAtomicOrbitals::toVec () const
{
   SX_CHECK (splineRep);
   if(splineRep)  {
      const SxVecRef<double> &radGFunc
         = SxConstPtr<SxRadialBasis>(basisPtr)->getRadFunc();
      int nSpecies = getNSpecies ();
      for (int is = 0; is < nSpecies; is++)   {
         int nOrbtypes = getNOrbTypes (is);
         for (int iot = 0; iot < nOrbtypes; iot++)   {
            SX_CHECK(is == muSet(is)(iot).auxData.is,
                     is, muSet(is)(iot).auxData.is);
            int ia = muSet(is)(iot).auxData.ia;
            int n = muSet(is)(iot).auxData.n;
            int l = muSet(is)(iot).auxData.l;
            int m = muSet(is)(iot).auxData.m;
            SxCubicSpline spline (radGFunc, muSet(is)(iot));
            muSet(is)(iot) = spline.getY (radGFunc);
            muSet(is)(iot).setBasis(&*basisPtr);
            muSet(is)(iot).auxData.is = is;
            muSet(is)(iot).auxData.ia = ia;
            muSet(is)(iot).auxData.n = char(n);
            muSet(is)(iot).auxData.l = char(l);
            muSet(is)(iot).auxData.m = char(m);
         }
      }
      splineRep = false;
   }
}

SxVector<double> SxAtomicOrbitals::toVec (int is, int iot) const
{
   SX_CHECK (splineRep);
   const SxVecRef<double> &radFunc = getRadFunc (is);
   SxCubicSpline spline (radFunc, muSet(is)(iot));
   SxVector<double> result = spline.getY (radFunc);
   return result;
}

void SxAtomicOrbitals::normalize ()
{
   int nSpecies = (int)muSet.getSize();
   for (int is = 0; is < nSpecies; is++)   {
      int nOrbTypes = (int)muSet(is).getSize ();
      for (int iot = 0; iot < nOrbTypes; iot++)   {
         double norm = getNormSqr(is,iot);
         if (norm > 1e-12) muSet(is)(iot) /= sqrt(norm);
         else {
            cout << "WARNING: Try to normalize zero norm orbital." << endl;
            cout << "Norm is " << norm << endl;
            cout << "Orbital is set to zero." << endl;
            muSet(is)(iot).set(0.0);
         }
      }
   }
}

SxArray<SxArray<SxVector<double> > > SxAtomicOrbitals::orthogonalize ()
{
   SX_CHECK(muSet.getSize() == funcLMap.getSize(),
            muSet.getSize(), funcLMap.getSize());
   // Gram-Schmidt via Cholesky
   SxAtomicOrbitals org = 1.0 * *this;
   int nSpecies = (int)muSet.getSize ();
   SxArray<SxArray<SxVector<double> > > result(nSpecies);
   for (int is = 0; is < nSpecies; is++)  {
      int lMax = getLMax(is);
      result(is).resize(lMax + 1);
      for (int l = 0; l <= lMax; l++)  {
         int nFL = getFuncPerL (is,l);
         if (nFL == 0) continue;
         SxVector<double> S = getOverlap(is,l);
         result(is)(l) = std::move(S).choleskyDecomposition ().transpose (). inverse ();
         for (int ifl = 0; ifl < nFL; ifl++)  {
            int iot = funcLMap(is)(l)(ifl);
            muSet(is)(iot).set(0.0);
            for (int jfl = 0; jfl < nFL; jfl++)  {
               muSet(is)(iot) += result(is)(l)(jfl,ifl) * org.getFuncL(is,l,jfl);
            }
         }
      }
   }

   // return CholeskyDecompositions
   return result;
}

SxArray<SxArray<SxVector<double> > > SxAtomicOrbitals::getOverlap () const
{
   int nSpecies = getNSpecies ();
   SxArray<SxArray<SxVector<double> > > result(nSpecies);
   for (int is = 0; is < nSpecies; is++)  {
      int lMax = getLMax(is);
      result(is).resize(lMax + 1);
      for (int l = 0; l <= lMax; l++)  {
         result(is)(l) = getOverlap (is, l);
      }
   }
   return result;
}

SxVector<double>  SxAtomicOrbitals::getOverlap (int is, int l) const
{
   int nFL = getFuncPerL (is,l);
   SxVector<double> result(nFL,nFL);
   for (int ifl = 0; ifl < nFL; ifl++)  {
      int iot = funcLMap(is)(l)(ifl);
      SxVecRef<double> vec1;
      if (splineRep) vec1 = toVec(is,iot);
      else           vec1 = muSet(is)(iot);
      for (int jfl = ifl; jfl < nFL; jfl++)  {
         int jot = funcLMap(is)(l)(jfl);
         SxVecRef<double> vec2;
         if (splineRep) vec2 = toVec(is,jot);
         else           vec2 = muSet(is)(jot);
         result(ifl,jfl) = result(jfl,ifl) = tr(vec1 * vec2);
      }
   }
   return result;
}

void SxAtomicOrbitals::refine (SxArray<int> &factor)
{
   SX_CHECK(basisPtr);
   const SxRadBasis &radBasis = getRadBasis ();

   int nSpecies = getNSpecies ();
   SX_CHECK(factor.getSize() == nSpecies, factor.getSize(), nSpecies);
   SxArray<SxVector<double> > rad(nSpecies);
   SxArray<double> logDr(nSpecies);
   for (int iSpecies = 0; iSpecies < nSpecies; iSpecies++) {
      SX_CHECK(factor(iSpecies) > 0, factor(iSpecies));
      if (factor(iSpecies) == 1) {
         cout << "Mesh for species " << (iSpecies + 1)
              << " not refined." << endl;
         rad(iSpecies) = radBasis.radFunc(iSpecies);
         logDr(iSpecies) = radBasis.logDr(iSpecies);
      }
      else  {
         // --- interpolate phi on finer mesh
         cout << "Refining mesh for species " << (iSpecies + 1)
              << " by factor " << factor(iSpecies) << "." << endl;
         double logDrOrig = radBasis.logDr(iSpecies);
         double r0 = radBasis.radFunc(iSpecies)(0);
         double r0New = r0;

         // --- define finer mesh
         int nrOrig = (int)radBasis.radFunc(iSpecies).getSize ();
         logDr(iSpecies) = logDrOrig / factor(iSpecies);
         int nExtra = (r0New < 0.) ? 0 : (int)(log(r0/r0New) / logDr(iSpecies));
         int nFine = (nrOrig-1)*factor(iSpecies) + 1 + nExtra;
         rad(iSpecies).resize(nFine);

         for (int i = 0; i < nFine; ++i)  {
            rad(iSpecies)(i) = r0 * exp(i * logDr(iSpecies));
         }

         // interpolate
         for (int iot = 0; iot < getNOrbTypes (iSpecies); iot++)  {
            // update rad,psi,logDr in psPot
            muSet(iSpecies)(iot)
               = interpolateRad (muSet(iSpecies)(iot),
                     radBasis.radFunc(iSpecies)(0),
                     radBasis.logDr(iSpecies),
                     rad(iSpecies));
         }
      }
   }
   setBasis (SxPtr<SxRadBasis>::create(rad,logDr));
}

SxVector<double>
SxAtomicOrbitals::compressWave (SxString &file, int iState, int iSpecies, int l)
{
   SxPW waves;
   SxAtomicStructure structure;
   try {
      SxBinIO io (file, SxBinIO::BINARY_READ_ONLY);
      waves = SxPW (file, SxPW::InMemory);
      structure.read (io);
      io.close ();
   }
   catch (SxException e)  {
      e.print ();
      SX_QUIT;
   }

   SxStack<double> xData;
   SxStack<double> yData;
   SxVector<double> yRad;
   SxVector<double> result;

   SxGkBasis &GkBasis = *waves.getGkBasisPtr ();
   GkBasis.changeTau(structure);
   double naNorm = 1.0/(structure.getNAtoms(iSpecies));
   double mNorm = 1.0/(2.0*l+1.0);
   double spinNorm = 1.0/double(waves.getNSpin ());

   for (int ik = 0; ik < waves.getNk(); ik++)  {
      yRad.resize(GkBasis(ik).g2.getSize());
      yRad.set(0.0);
      for (int iSpin = 0; iSpin < waves.getNSpin (); iSpin++)  {
         for (int iAtom = 0; iAtom < structure.getNAtoms(iSpecies); iAtom++)  {
            for (int m = -l; m <= l; m++)  {
               SxVector<double> wave = sqrt(waves(iState,iSpin,ik).absSqr ());
               SxVector<SxComplex16> radial = wave
                  * GkBasis(ik).getPhaseFactors(iSpecies,iAtom).conj () //shift
                  * GkBasis(ik).getYlm(l,m) // project l
                  * SxYlm::getYlmNormFactor(l,m)
                  * sqrt(2.0 * structure.cell.volume/PI)
                  * spinNorm
                  * naNorm
                  * mNorm;
               yRad += radial.real ();
            }
         }
      }
      for (int i = 0; i < GkBasis(ik).g2.getSize(); i++)  {
         xData.push(sqrt(GkBasis(ik).g2(i)));
         yData.push(yRad(i));
      }
   }

   SxVector<double> xToFit(xData);
   SxVector<double> yToFit(yData);

   SxCubicSpline fit;
   SxRadialBasis radGBasis (0.0, GkBasis.getMaxGk(), 100, /*realSpace*/ false,
                            SxRadialBasis::Linear);
   if (l == 0) // ?(May have CUSP, no Mirror)?
      fit  = SxCubicSpline (
            xToFit,
            yToFit,
            radGBasis.getRadFunc(),
            SxCubicSpline::Natural,
            SxCubicSpline::MirrorPlane);
   else if (l & 1) // (l odd)
      fit  = SxCubicSpline (
            xToFit,
            yToFit,
            radGBasis.getRadFunc(),
            SxCubicSpline::Natural,
            SxCubicSpline::MirrorPoint);
   else // (l even and not zero)
      fit  = SxCubicSpline (
            xToFit,
            yToFit,
            radGBasis.getRadFunc(),
            SxCubicSpline::Natural,
            SxCubicSpline::MirrorPlane);
   SxVector<double> resultG = fit.getYFit ();
   resultG.setBasis(&radGBasis);
   resultG.auxData.setAtom (iSpecies, -1);
   resultG.auxData.setOrb (-1, l, NONE_M);

   result = *basisPtr | resultG;

   result.auxData.setAtom (iSpecies, -1);
   result.auxData.setOrb (-1, l, NONE_M);

   // ensure localization
   SxVector<double> rCut (getRadFunc(iSpecies).getSize ());
   rCut.set(10.0);
   result *= 1.0 / (1.0 + exp(getRadFunc(iSpecies) - rCut));

   result.normalize ();

   return result;
}

#ifdef USE_HDF5
void SxAtomicOrbitals::writeHDF5(const SxString &name)
{
   SxHDF5 file (name, SxHDF5::BINARY_CREATE);
   SxArray<SxArray<int> > funcPerL = getFuncPerL ();
   for (int is = 0; is < funcPerL.getSize (); is++)  {
      SxString isName = "Species-" + SxString(is);
      file.createGroup(isName);
      file.enterGroup(isName);
      SxString basisName = "radBasis";
      file.writeVector(basisName, getRadFunc(is));
      for (int l = 0; l < funcPerL(is).getSize(); l++)  {
         SxString lName = "Angularmomentum-" + SxString(l);
         file.createGroup(lName);
         file.enterGroup(lName);
         for (int il = 0; il < funcPerL(is)(l); il++)  {
            SxString radName = "Radial-" + SxString(il);
            file.writeVector(radName, getFuncL(is,l,il));
         }
         file.leaveGroup();
      }
      file.leaveGroup();
   }
}
#endif

void SxAtomicOrbitals::orthogonalizeOn(SxAtomicOrbitals &basis)
{
   //Gram-Schmidt ortho
   bool switchThis = false;
   bool switchBasis = false;
   int nSpecies = (int)muSet.getSize ();
   SX_CHECK(nSpecies == basis.muSet.getSize());

   if (isSpline()) {
      toVec ();
      switchThis = true;
   }

   if (basis.isSpline())  {
      basis.toVec ();
      switchBasis = true;
   }

   for (int is = 0; is < nSpecies; is++)  {
      int lMax = getLMax(is);
      SX_CHECK(lMax <= basis.getLMax(is));
      for (int l = 0; l <= lMax; l++)  {
         int nFL = getFuncPerL(is,l);
         int nFLbasis = basis.getFuncPerL(is,l);
         for (int ifl = 0; ifl < nFL; ifl++)  {
            int iot = funcLMap(is)(l)(ifl);
            SxVector<double> vec = muSet(is)(iot);
            for (int jfl = 0; jfl < nFLbasis; jfl++)  {
               int jot = basis.funcLMap(is)(l)(jfl);
               muSet(is)(iot) -= tr(vec * basis.muSet(is)(jot))
                               / basis.getNormSqr(is,jot) * basis.muSet(is)(jot);
            }
         }
      }
   }

   if (switchThis) toSpline ();
   if (switchBasis) basis.toSpline ();
}

void SxAtomicOrbitals::rotate(const SxArray<SxArray<SxVector<double> > > &rotMat)
{
   SX_CHECK(muSet.getSize() == funcLMap.getSize(),
            muSet.getSize(), funcLMap.getSize());
   // Gram-Schmidt via Cholesky
   SxAtomicOrbitals org = 1.0 * *this;
   int nSpecies = (int)muSet.getSize ();
   SX_CHECK (nSpecies == rotMat.getSize(),nSpecies, rotMat.getSize());
   for (int is = 0; is < nSpecies; is++)  {
      int lMax = getLMax(is);
      SX_CHECK (lMax + 1 == rotMat(is).getSize(), lMax + 1, rotMat(is).getSize());
      for (int l = 0; l <= lMax; l++)  {
         int nFL = getFuncPerL (is,l);
         SX_CHECK (nFL == rotMat(is)(l).getNCols (), nFL, rotMat(is)(l).getNCols ());
         for (int ifl = 0; ifl < nFL; ifl++)  {
            int iot = funcLMap(is)(l)(ifl);
            muSet(is)(iot).set(0.0);
            for (int jfl = 0; jfl < nFL; jfl++)  {
               muSet(is)(iot) += rotMat(is)(l)(jfl,ifl) * org.getFuncL(is,l,jfl);
            }
         }
      }
   }
}

