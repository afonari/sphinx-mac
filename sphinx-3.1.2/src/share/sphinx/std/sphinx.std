// ---------------------------------------------------------------------------
//
//      The ab-initio based multiscale library
//
//                  S / P H I / n X
//
//      Copyright:  Max-Planck-Institut fuer Eisenforschung GmbH
//                  40237 Duesseldorf, Germany
//
//      Contact:    https://sxrepo.mpie.de
//      Authors:    see sphinx/AUTHORS
//      License:    see sphinx/LICENSE
//
// ---------------------------------------------------------------------------
// Rather strict input file format definitions:
//    * variables may be defined only in top level node
//    * k-Points for bandstructures (path through the Brillouin zone) are
//      expected in cartesion coordinates
//    * k-Points used in the Monkhorst-Pack folding are expected in 
//      relative coordinates
//    * energy-cutoff limited 
// --------------------------------------------------------------------------
set validation;


topLevelDefs;

// Declare global "skipUnexpectedGroups". See also footer of this file.
skipUnexpectedGroups;

include <std/structure.std>;
include <std/taylorExpPotential.std>;

synchronize          { type="group"; maxItems=1; optional;
   leaveOnRemote     { type="group"; optional;
      file           { type="string"; }
   }
}

include <std/basis.std>;

PWHamiltonian        { type="group"; nItems=1; optional;
   nEmptyStates      { type="int"; min=0; optional; }
   nEmptyStatesChi   { type="int"; min=0; optional; }
   vExt              { type="group"; optional; 
      file           { type="string"; }
      actOnNuclei    { type="flag"; optional; }
   }
   nExcessElectrons  { type="real"; min=-1000; max=1000; optional; }
   ekt               { type="real"; min=0; }
   MethfesselPaxton  { type="int"; min=0; optional; }
   FermiDirac        { type="int"; min=0; max=1; optional; }
   xc                { type="int"; min=0; max=10; }
   xcMesh            { type="group"; optional;
      eCut              { type="real"; min=5; xor="eCut,mesh,meshAccuracy";}
      mesh              { type="vector"; dim=3; xor="eCut,mesh,meshAccuracy";}
      meshAccuracy      { type="real"; xor="eCut,mesh,meshAccuracy";}
   }
   spinPolarized     { type="flag"; optional; }
   hContrib          { type="int"; optional; }
   nlBlockSize       { type="int"; optional; min=1; }
   dipoleCorrection  { type="flag"; optional; }
   zField            { type="real"; optional; }
   nlEES             { type="group"; optional;
      mesh           { type="vector"; dim=3; optional; }
      meshAccuracy   { type="real"; min=0.5; optional; }
      splineOrder    { type="int"; min=2; }
   }
   rsProj            { type="group"; optional; xor="nlEES,rsProj";
      mesh           { type="vector"; dim=3; optional; }
      meshAccuracy   { type="real"; min=0.5; optional; }
      beta           { type="real"; min=0.; }
      rMax           { type="real"; min=1.; optional; }
      dPhi           { type="real"; min=0.; }
      dg             { type="real"; min=0.; }
   }
   include <std/vdwCorrection.std>;
}

include <std/kpHamiltonian.std>;
include <std/strain.std>;
include <std/kpParameters.std>;
include <std/materialMap.std>;

StilWeb              { type="group"; nItems=1; optional;
   // empty
}

initialGuess         { type="group"; nItems=1; optional;
                       xor="initialGuess,tbInitialGuess,forstDB,stilWeb,eamPot,taylorExpPotential"; 
   waves             { type="group"; nItems=1; optional;
      random         { type="flag";            xor="file,random,lcao"; }
      file           { type="string";          xor="file,random,lcao"; }
      lcao           { type="group"; nItems=1; xor="file,random,lcao";
         maxSteps    { type="int"; min=1; }
         include <std/rhoMixing.std>;
         foccMixing  { type="real"; min=0.; max=1.; optional; }
         file        { type="string"; optional; }
      }             
      keepWavesOnDisk { type="flag"; optional; }
   }                 
   rho               { type="group"; nItems=1; optional;
      file           { type="string"; 
                       xor="file,atomicOrbitals,fromWaves,random"; }
      atomicOrbitals { type="flag";  
                       xor="file,atomicOrbitals,fromWaves,random"; }
      fromWaves      { type="flag";  
                       xor="file,atomicOrbitals,fromWaves,random"; }
      random         { type="flag";  
                       xor="file,atomicOrbitals,fromWaves,random";}                 
      spinMoment     { type="real"; min=-100; max=100; optional; 
                       and="atomicOrbitals"; }
      charged { type="group"; optional;
         charge { type="real"; }
         beta   { type="real"; optional; }
         z      { type="real"; xor="z,coords"; }
         coords { type="vector"; dim=3; xor="z,coords"; }
      }
   }
   xcPotential        { type="group"; nItems=1; optional;
      file           { type="string";          xor="file,compute"; }
      compute        { type="group"; nItems=1; xor="file,compute";
         xc          { type="int"; min=0; max=2; }
      }
   }
   ekt               { type="real"; min=0; max=5; optional; }

   include <std/initOccupations.std>;

   noWavesStorage { type="flag"; optional; }
   noRhoStorage { type="flag"; optional; }
}                

tbInitialGuess       { type="group"; nItems=1; xor="initialGuess,tbInitialGuess,forstDB,stilWeb,eamPot,taylorExpPotential";
   withoutERepulsive { type="flag"; optional;}
      rhoFile        { type="string"; optional; } 
}

main                 { type="group"; nItems=1;
   Hirshfeld { type="flag"; optional; }
   include <std/eam.std>;
   include <std/elmin.std>;
   include <std/gsexx.std>;
   include <std/stexx.std>;
   include <std/odp.std>;
   include <std/qn.std>;
   include <std/linqn.std>;
   include <std/ricqn.std>;
   include <std/ricts.std>;
   include <std/moldyn.std>;
   include <std/frozenPhonon.std>;
   include <std/hSqrCG.std>;
   include <std/diffEqtn.std>;
   include <std/extControl.std>;
   evalForces { type="group"; optional;
      file { type="string"; optional; }
   }
}



// --- Put value back to false. It might have been overwriten by included stds.
skipUnexpectedGroups = false;
