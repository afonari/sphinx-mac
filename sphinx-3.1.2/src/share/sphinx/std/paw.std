// ---------------------------------------------------------------------------
//
//      The ab-initio based multiscale library
//
//                  S / P H I / n X
//
//      Copyright:  Max-Planck-Institut fuer Eisenforschung GmbH
//                  40237 Duesseldorf, Germany
//
//      Contact:    https://sxrepo.mpie.de
//      Authors:    see sphinx/AUTHORS
//      License:    see sphinx/LICENSE
//
// ---------------------------------------------------------------------------
// Rather strict input file format definitions:
//    * variables may be defined only in top level node
//    * k-Points for bandstructures (path through the Brillouin zone) are
//      expected in cartesion coordinates
//    * k-Points used in the Monkhorst-Pack folding are expected in 
//      relative coordinates
//    * energy-cutoff limited 
// --------------------------------------------------------------------------
set validation;


deprecateFormat;
topLevelDefs;

// Declare global "skipUnexpectedGroups". See also footer of this file.
skipUnexpectedGroups;

include <std/structure.std>;

pawPot              { type="group"; maxItems=1; optional; 
  species           { type="group"; minItems=1; 
     name           { type="string"; optional;}
     element        { type="string"; optional; }
     potential      { type="string"; }
     potType        { type="string"; }
         
     gyromagneticRatio { type="real"; optional; }

     reciprocalMass { type="real"; min=0; optional; }
     dampingMass    { type="real"; min=0; optional; }
     ionicMass      { type="real"; min=0; optional; }
     valenceCharge  { type="real"; min=0; max=104; optional; }
     atomicRhoOcc   { type="list"; minRank=0; maxRank=2; optional; }

     lMaxRho        { type="int"; min=0; optional; }
     angularGrid    { type="int"; min=0; max=31; optional; }
     nRadGrid       { type="int"; min=100; optional; }
     rPAW           { type="real"; min=0; optional; }

     coreX          { type="matrix"; optional; }
     coreWaves      { type="string"; optional; }

     checkOverlap   { type="flag"; optional; }
     useProjG       { type="flag"; optional; }
     recomputeTail  { type="flag"; optional; }
  }
  kjxc { type="flag"; optional; }
  verbose { type="flag"; optional; }
  useProjG { type="flag"; optional; }
}

include <std/basis.std>;

aoBasis { type="group"; nItems=1; optional;
   file { type="string"; optional; }
   fromPotential { type="flag"; optional; }
}

initialGuess { type="group"; nItems=1; optional;

   waves             { type="group"; nItems=1; optional;
      random         { type="flag";            xor="file,random,lcao"; }
      file           { type="string";          xor="file,random,lcao"; }
      lcao           { type="group"; nItems=1; xor="file,random,lcao";
         file        { type="string";  optional; }
         maxSteps    { type="int"; min=0; max=50; optional;}
         dEnergy     { type="real"; min=0; optional;}
         basisDecomposition {type="flag"; optional;  }
         pulayForces { type="flag"; optional; }
         // mixer parameters
         include <std/rhoMixing.std>;
      }
      keepWavesOnDisk { type="flag"; optional; }
      changeCharge { type="flag"; optional; needs="file"; }
      pawBasis        { type="flag"; optional; xor="keepWavesOnDisk,pawBasis"; }
   }

   exchange          { type="group"; nItems=1; optional;
      file           { type="string";}
   }

   rho               { type="group"; nItems=1;
      file           { type="string";
                       xor="file,atomicOrbitals,fromWaves,random"; }
      atomicOrbitals { type="flag";
                       xor="file,atomicOrbitals,fromWaves,random"; }
      fromWaves      { type="flag";
                       xor="file,atomicOrbitals,fromWaves,random"; }
      random         { type="flag";
                       xor="file,atomicOrbitals,fromWaves,random"; }
      atom { type="group"; optional; and="atomicOrbitals";
         label { type="string"; }
         spin  { type="real"; optional; xor="focc";} // deprecated
         focc  { type="list"; minRank=0; maxRank=2; optional; xor="spin";}
      }
      aspherical { type="group"; optional; xor="aspherical,atom,atomicSpin";
         element { type="string"; optional; xor="element,label"; }
         label   { type="string"; optional; xor="element,label"; }
         l       { type="int"; optional; }
         orbital { type="group";
            eigenvector { type="list"; minRank=1; maxRank=2; }
            focc  { type="real"; }
            iSpin { type="int"; optional; }
         }
         sphericalFocc { type="list"; }
      }
      atomicSpin { type="group"; optional; and="atomicOrbitals"; xor="spinMoment";
         file  { type="string"; optional; xor="file,label";}
         label { type="string"; optional; xor="file,label";}
         spin  { type="real"; optional; xor="file,spin";}
       }
      spinMoment     { type="real"; min=-100; max=100; optional;
                       and="atomicOrbitals"; }
      charged { type="group"; optional;
         charge { type="real"; }
         beta   { type="real"; optional; }
         z      { type="real"; xor="z,coords"; }
         coords { type="vector"; dim=3; xor="z,coords"; }
      }
   }

   include <std/initOccupations.std>;
   noWavesStorage { type="flag"; optional; }
   noRhoStorage { type="flag"; optional; }
}

spinConstraint       { type="group"; optional;
   label { type="string"; xor="file"; optional; }
   file  { type="string"; xor="label"; optional; }
   constraint { type="real"; optional; }
}

PAWHamiltonian        { type="group"; nItems=1; optional;
   vdwCorrection      { type="group"; optional;
         method { type="enum";
                     val = "D2,TS,D3,D3+TS,TSI,D3+TSI"; }
         combinationRule { type="enum"; optional;
                     val = "GB,Tang"; }
         damping {type="enum"; optional;
                     val = "Fermi, BJ"; }
   }
   nEmptyStates      { type="int"; min=0; optional; }
   vExt              { type="group"; optional; 
      file { type="string"; }
   }
   nExcessElectrons  { type="real"; min=-1000; max=1000; optional; }
   ekt               { type="real"; min=0; }
   MethfesselPaxton  { type="int"; min=0; optional; }
   FermiDirac        { type="int"; min=0; max=1; optional; }
   xc                { type="int"; min=0; max=33; }
   xcMesh            { type="group"; optional;
      eCut              { type="real"; min=5; xor="eCut,mesh,meshAccuracy";}
      mesh              { type="vector"; dim=3; xor="eCut,mesh,meshAccuracy";}
      meshAccuracy      { type="real"; xor="eCut,mesh,meshAccuracy";}
   }
   omegaHSE          { type="real"; optional; }
   alphaHybrid       { type="real"; optional; }
   spinPolarized     { type="flag"; optional; }
   hContrib          { type="int"; optional; }
   //nlBlockSize       { type="int"; optional; min=1; }
   dipoleCorrection  { type="flag"; optional; }
   fixedDipoleZ      {type="real"; optional;}
   zField            {type="real"; optional;}
   rSoft             {type="real"; optional; min=0;}
   writeHirshfeldCharges {type="flag"; optional;}
   HubbardU { type="group"; optional;
      verbose { type="flag"; optional; }
      site { type="group"; optional;
         element { type="string"; optional; xor="element,species,label"; }
         species { type="int"; optional; xor="element,species,label"; }
         label   { type="string"; optional; xor="element,species,label"; }

         l             { type="int"; optional; xor="l,projectorType"; }
         projectorType { type="int"; optional; xor="l,projectorType"; }
         U             { type="real"; }
         shift         { type="real"; optional; }

         update { type="flag"; optional; }
      }
      MO { type="group"; optional;
         verbose { type="flag"; optional; }

         element { type="string"; optional; xor="element,species,label"; }
         species { type="int"; optional; xor="element,species,label"; }
         label   { type="string"; optional; xor="element,species,label"; }

         minDist { type="real"; min=0.; optional; }
         maxDist { type="real"; min=0.; }
         nInterpolate { type="int"; min=10; optional; }

         orbital { type="group";
            fromPotential { type="flag"; optional; xor="fromPotential,file"; }
            file { type="string"; optional; xor="fromPotential,file"; }
            iot { type="int";   min=0;}
            // take from this species in file (default: same as element)
            is  { type="int"; optional; min=0;}
         }
         nRadGrid { type="int"; min=100; optional; }
         rCut { type="real"; min=0.; }
         cutWidth { type="real"; min=0.; optional; }
         // rotational quantum number along the molecular axis
         mMO { type="int"; min=0; }
         sign { type="int"; min=-1; max=1; }
         setupBoxSize { type="real"; min=10.; optional; }

         U             { type="real"; }
         shift         { type="real"; optional; }

         //update { type="flag"; optional; }

      }
      AO { type="group"; optional;
         verbose { type="flag"; optional; }

         element { type="string"; optional; xor="element,species,label"; }
         species { type="int"; optional; xor="element,species,label"; }
         label   { type="string"; optional; xor="element,species,label"; }

         orbital { type="group";
            fromPotential { type="flag"; optional; xor="fromPotential,file"; }
            file { type="string"; optional; xor="fromPotential,file"; }
            iot { type="int";   min=0;}
            // take from this species in file (default: same as element)
            is  { type="int"; optional; min=0;}
         }
         nRadGrid { type="int"; min=100; optional; }
         rCut { type="real"; min=0.; }
         cutWidth { type="real"; min=0.; optional; }

         U             { type="real"; }
         shift         { type="real"; optional; }

         //update { type="flag"; optional; }

      }
      include <std/fragmentOrbital.std>;
   }
}

main                 { type="group"; nItems=1;
   Hirshfeld { type="flag"; optional; }
   evalForces { type="group"; optional;
      file { type="string"; optional; }
   }
   include <std/ccg.std>;
   include <std/linqnPAW.std>;
   include <std/ricqn.std>;
   include <std/ricts.std>;
   include <std/qn.std>;
   include <std/scf.std>;
   include <std/bandstruct.std>;
   include <std/moldyn.std>;
   include <std/frozenPhonon.std>;
   include <std/lcao.std>;
   include <std/extControl.std>;
   include <std/pDos.std>;
   updateHubbard { type="group"; optional;
      siteIds { type="list"; }
      U       { type="real"; optional; }
      shift   { type="real"; optional; }
   }
}

// --- Put value back to false. It might have been overwriten by included stds.
skipUnexpectedGroups = false;
