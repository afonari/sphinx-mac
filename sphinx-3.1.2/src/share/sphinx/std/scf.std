subspaceDiag { type="group"; optional;
   ekt               { type="real"; min=0; optional; }
   fermiDistribution { type="flag"; optional; }
}

scfDiag             { type="group"; optional;
   ekt              { type="real"; min=0; optional; }
   keepRhoFixed     { type="flag"; optional; }
   keepOccFixed     { type="flag"; optional; }
   keepSpinFixed    { type="flag"; optional; not="keepOccFixed"; }
   spinMoment       { type="real"; optional; not="keepOccFixed"; }
   propagateWaves   { type="flag"; optional; }
   useKS            { type="flag"; optional; not="keepRhoFixed";}
   
   dRelRes          { type="real"; min=0; optional; }
   dSpinMoment      { type="real"; min=0; optional; } // for atomic spin constraints
   maxSteps         { type="int"; min=1; optional; }
   dEnergy          { type="real"; min=0; optional; }
   dEnergyLow       { type="real"; min=0; optional; }
   maxResidue       { type="real"; min=0; optional; }

   printVarEnergy   { type="flag"; optional;}
   
   xcMesh           { type="group"; optional;
      eCut             { type="real"; min=5; xor="eCut,mesh,meshAccuracy";}
      mesh             { type="vector"; dim=3; xor="eCut,mesh,meshAccuracy";}
      meshAccuracy     { type="real"; xor="eCut,mesh,meshAccuracy";}
   }
   dipoleCorrection { type="flag"; optional; }
   calcForces       { type="flag"; optional; }

   CCG { type="group"; optional;
      dRelEps          { type="real"; min=0; max=1; optional; }
      maxStepsCCG      { type="int"; optional; }
      dEnergy          { type="real"; min=0; optional; }
      xcMesh            { type="group"; optional;
         eCut              { type="real"; min=5; xor="eCut,mesh,meshAccuracy";}
         mesh              { type="vector"; dim=3; xor="eCut,mesh,meshAccuracy";}
         meshAccuracy      { type="real"; xor="eCut,mesh,meshAccuracy";}
      }
   }
   rmmDiis { type="group"; optional;
      verbose          { type="flag"; optional; }
      maxStepsCCG      { type="int"; optional; }
      dRelR            { type="real"; min=0; optional; }
      dEnergy          { type="real"; min=0; optional; }
      xcMesh            { type="group"; optional;
         eCut              { type="real"; min=5; xor="eCut,mesh,meshAccuracy";}
         mesh              { type="vector"; dim=3; xor="eCut,mesh,meshAccuracy";}
         meshAccuracy      { type="real"; xor="eCut,mesh,meshAccuracy";}
      }
   }
   blockCCG { type="group"; optional;
      dRelEps          { type="real"; min=0; max=1; optional; }
      maxStepsCCG      { type="int"; optional; }
      blockSize        { type="int"; min = 1; optional; }
      verbose          { type="flag"; optional; }
      numericalLimit   { type="flag"; optional; }
      nSloppy          { type="int"; optional; }
      dEnergy          { type="real"; min=0; optional; }
      xcMesh            { type="group"; optional;
         eCut              { type="real"; min=5; xor="eCut,mesh,meshAccuracy";}
         mesh              { type="vector"; dim=3; xor="eCut,mesh,meshAccuracy";}
         meshAccuracy      { type="real"; xor="eCut,mesh,meshAccuracy";}
      }
   }
   blockRmmDiis { type="group"; optional;
      verbose          { type="flag"; optional; }
      maxStepsCCG      { type="int"; optional; }
      blockSize        { type="int"; min = 1; optional; }
      dRelR            { type="real"; min=0; optional; }
      dEnergy          { type="real"; min=0; optional; }
      xcMesh            { type="group"; optional;
         eCut              { type="real"; min=5; xor="eCut,mesh,meshAccuracy";}
         mesh              { type="vector"; dim=3; xor="eCut,mesh,meshAccuracy";}
         meshAccuracy      { type="real"; xor="eCut,mesh,meshAccuracy";}
      }
   }
   blockRmmCG { type="group"; optional;
      verbose          { type="flag"; optional; }
      maxStepsCCG      { type="int"; optional; }
      blockSize        { type="int"; min = 1; optional; }
      dRelR            { type="real"; min=0; optional; }
      dEnergy          { type="real"; min=0; optional; }
      xcMesh            { type="group"; optional;
         eCut              { type="real"; min=5; xor="eCut,mesh,meshAccuracy";}
         mesh              { type="vector"; dim=3; xor="eCut,mesh,meshAccuracy";}
         meshAccuracy      { type="real"; xor="eCut,mesh,meshAccuracy";}
      }
   }

   include <std/rhoMixing.std>;

   noRhoStorage     { type="flag"; optional; }
   noWavesStorage   { type="flag"; optional; }
   printSteps       { type="int"; min=0; optional; }
   dumpTime { type="real"; optional; }

}
